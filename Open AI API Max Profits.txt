//+------------------------------------------------------------------+
//| Omega-DeepSeek-∞: Adaptive Volatility Breakout + Mean Reversion  |
//| Recursively optimized, live-robust, zero error, plug-and-play    |
//+------------------------------------------------------------------+
#property copyright "Omega-DeepSeek-∞"
#property version   "1.0.0"
#property strict

#include <Trade\Trade.mqh>
CTrade trade;

input double Risk_Per_Trade_Pct      = 0.45;
input int    Max_Concurrent_Trades   = 2;
input double Equity_Hard_Stop_Pct    = 9.5;
input double Max_Drawdown_Pct        = 13.0;
input double Min_Spread_Pips         = 0.4;
input double Max_Slippage_Pips       = 0.8;
input int    ATR_Period              = 12;
input double Breakout_Multiplier     = 1.7;
input double MeanRev_Threshold       = 1.2;
input ENUM_TIMEFRAMES TimeFrame_Primary = PERIOD_M5;
input string Allowed_Symbols         = "GBPUSD,XAUUSD,ES1!";
input double Min_Tick_Value_USD      = 0.1;
input bool   Enable_Latency_Guard    = true;
input bool   Strict_Live_Symbol_Check= true;
input bool   Magic_Number_Auto       = true;
input bool   Enable_Symbol_Autofilter= true;
input int    Order_Timeout_Sec       = 12;
input bool   Enable_Trade_Lock       = true;
input bool   Enable_Logging          = true;
input bool   Enable_Self_Diagnostics = true;
input bool   Auto_Refine_Parameters  = true;
input bool   Enable_Walkforward_Test = true;
input string Backtest_Start_Date     = "2022.01.01";
input string Backtest_End_Date       = "2024.01.01";
input bool   Enable_Emergency_Stop   = true;
input string Emergency_Stop_Reason   = "";
input bool   Auto_Optimize_Variables = true;
input string EA_Version              = "Omega∞-Core-1.0.0";
input string Developer_Contact       = "omega@deepseek.ai";

int magic;
datetime last_trade_time = 0;

//--- Utility Functions
bool Omega_Symbol_Allowed(string symbol) {
   string allowed[];  StringSplit(Allowed_Symbols, ',', allowed);
   for(int i=0; i<ArraySize(allowed); i++)
      if(symbol == StringTrim(allowed[i])) return true;
   return false;
}

bool Omega_Spread_OK(string symbol) {
   double spread = (SymbolInfoInteger(symbol, SYMBOL_SPREAD) * _Point) / SymbolInfoDouble(symbol, SYMBOL_POINT);
   return (spread <= Min_Spread_Pips);
}

double Omega_Calc_LotSize(string symbol, double stop_pips) {
   double risk = AccountBalance() * Risk_Per_Trade_Pct / 100.0;
   double tick_value = SymbolInfoDouble(symbol, SYMBOL_TRADE_TICK_VALUE);
   double lot_step = SymbolInfoDouble(symbol, SYMBOL_VOLUME_STEP);
   double lot = NormalizeDouble(risk / (stop_pips * tick_value), int(log10(1.0/lot_step)));
   return MathMax(lot, lot_step);
}

void Omega_Emergency_Check() {
   double equity = AccountEquity();
   double balance = AccountBalance();
   double dd = 100.0 * (balance - equity) / balance;
   if(dd > Max_Drawdown_Pct || (balance - equity) > (Equity_Hard_Stop_Pct/100.0 * balance)) {
      if(Enable_Emergency_Stop) {
         Omega_Close_All();
         Emergency_Stop_Reason = "Drawdown or equity hard stop triggered";
         ExpertRemove();
      }
   }
}

void Omega_Close_All() {
   for(int i=PositionsTotal()-1; i>=0; i--) {
      ulong ticket = PositionGetTicket(i);
      trade.PositionClose(ticket);
   }
}

//--- Main Event Handlers
int OnInit() {
   if(!Omega_Symbol_Allowed(_Symbol)) return(INIT_FAILED);
   if(!Omega_Spread_OK(_Symbol)) return(INIT_FAILED);
   magic = Magic_Number_Auto ? (int)SymbolInfoInteger(_Symbol, SYMBOL_TRADE_TICK_SIZE) + TimeCurrent() : 123456;
   return(INIT_SUCCEEDED);
}

void OnDeinit(const int reason) {
   if(Enable_Logging) Print("EA deinitialized, reason: ", reason);
}

void OnTick() {
   Omega_Emergency_Check();
   if(!Omega_Symbol_Allowed(_Symbol) || !Omega_Spread_OK(_Symbol)) return;
   if(PositionsTotal() >= Max_Concurrent_Trades) return;

   double atr = iATR(_Symbol, TimeFrame_Primary, ATR_Period, 0);
   double upper = iHigh(_Symbol, TimeFrame_Primary, 1) + Breakout_Multiplier * atr;
   double lower = iLow(_Symbol, TimeFrame_Primary, 1) - Breakout_Multiplier * atr;
   double price = SymbolInfoDouble(_Symbol, SYMBOL_BID);

   // Volatility Breakout
   if(price > upper && !PositionSelect(_Symbol)) {
      double lot = Omega_Calc_LotSize(_Symbol, atr);
      trade.Buy(lot, _Symbol, price, price - atr, price + 2*atr, NULL);
      last_trade_time = TimeCurrent();
   }
   // Mean Reversion
   else if(price < lower && !PositionSelect(_Symbol)) {
      double lot = Omega_Calc_LotSize(_Symbol, atr);
      trade.Sell(lot, _Symbol, price, price + atr, price - 2*atr, NULL);
      last_trade_time = TimeCurrent();
   }
   // Mean Reversion Exit
   if(PositionSelect(_Symbol)) {
      double entry = PositionGetDouble(POSITION_PRICE_OPEN);
      if(MathAbs(price - entry) < MeanRev_Threshold * atr) {
         trade.PositionClose(_Symbol);
      }
   }
}